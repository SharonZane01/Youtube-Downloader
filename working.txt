import customtkinter as ctk
import yt_dlp
import threading
import os
import sys
from tkinter import filedialog, messagebox
import platform

# --- App Settings ---
ctk.set_appearance_mode("dark")
ctk.set_default_color_theme("blue")

def get_root_path(relative_path):
    """ Get absolute path to a resource in the app's root directory. """
    try:
        # For PyInstaller .exe, the base_path is the directory of the executable
        if getattr(sys, 'frozen', False):
            base_path = os.path.dirname(sys.executable)
        else:
            # For a normal script, it's the script's directory
            base_path = os.path.abspath(os.path.dirname(__file__))
    except Exception:
        base_path = os.path.abspath(".")
    return os.path.join(base_path, relative_path)


def get_asset_path(relative_path):
    """ Get absolute path to a resource in the 'assets' subdirectory. """
    return get_root_path(os.path.join('assets', relative_path))

def get_executable_path(name):
    """ Get the path to a bundled executable """
    asset_path = get_asset_path(f"{name}.exe" if platform.system() == "Windows" else name)
    return asset_path


class App(ctk.CTk):
    def __init__(self):
        super().__init__()

        # --- Window Config ---
        self.title("Py Downloader Pro")
        self.geometry("720x580") # Adjusted height back after removing menu
        self.minsize(640, 500)
        self.protocol("WM_DELETE_WINDOW", self.on_closing)
        
        self.is_closing = False
        self.current_url = ""

        # --- Grid Config ---
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=1)

        # --- Setup yt-dlp Options ---
        self.setup_yt_dlp()
        
        # --- Create UI ---
        self.create_header()
        self.create_main_content()
        self.create_status_footer()

    def setup_yt_dlp(self):
        """Sets the static, base options for all yt-dlp calls, including cookies.txt."""
        
        # Define paths for dependencies
        ffmpeg_path = get_executable_path("ffmpeg")
        cookies_path = get_root_path('cookies.txt')

        self.ydl_base_opts = {
            'quiet': True,
            'no_warnings': True,
            'ffmpeg_location': ffmpeg_path,
            'nocheckcertificate': True,
            'http_headers': {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36'
            }
        }

        # ** THIS IS THE KEY CHANGE **
        # Automatically add the cookie file to the options if it exists.
        if os.path.exists(cookies_path):
            self.ydl_base_opts['cookiefile'] = cookies_path
            print(f"‚úÖ Found and using cookies from: {cookies_path}")
        else:
            print(f"‚ÑπÔ∏è 'cookies.txt' not found in project folder. Downloads may fail for private/member-only content.")


    def create_header(self):
        """Create the simplified header with only the URL input."""
        header_frame = ctk.CTkFrame(self, corner_radius=0, fg_color="transparent")
        header_frame.grid(row=0, column=0, sticky="ew", padx=15, pady=(15, 10))
        header_frame.grid_columnconfigure(0, weight=1)

        # URL Entry and Analyze button
        self.url_entry = ctk.CTkEntry(header_frame, placeholder_text="Paste your YouTube URL here...", height=40, font=ctk.CTkFont(size=13))
        self.url_entry.grid(row=0, column=0, sticky="ew", padx=(0, 10))

        self.get_info_button = ctk.CTkButton(header_frame, text="Analyze", command=self.get_video_info_thread, height=40, width=100, font=ctk.CTkFont(size=13, weight="bold"))
        self.get_info_button.grid(row=0, column=1)

    def create_main_content(self):
        self.main_frame = ctk.CTkFrame(self, fg_color="transparent")
        self.main_frame.grid(row=1, column=0, sticky="nsew", padx=15, pady=0)
        self.main_frame.grid_columnconfigure(0, weight=1)
        self.main_frame.grid_rowconfigure(1, weight=1)
        
        self.video_title_label = ctk.CTkLabel(self.main_frame, text="Enter a YouTube URL to begin", font=ctk.CTkFont(size=14, weight="bold"), wraplength=650, anchor="w")
        self.video_title_label.grid(row=0, column=0, sticky="ew", pady=(5, 10))
        
        self.scrollable_frame = ctk.CTkScrollableFrame(self.main_frame, label_text="Available Formats", label_font=ctk.CTkFont(size=12, weight="bold"))
        self.scrollable_frame.grid(row=1, column=0, sticky="nsew")
        self.scrollable_frame.grid_columnconfigure(0, weight=1)

    def create_status_footer(self):
        footer_frame = ctk.CTkFrame(self, corner_radius=0, fg_color="transparent")
        footer_frame.grid(row=2, column=0, sticky="ew", padx=15, pady=(10, 15))
        footer_frame.grid_columnconfigure(0, weight=1)

        self.status_label = ctk.CTkLabel(footer_frame, text="Ready", anchor="w", font=ctk.CTkFont(size=12))
        self.status_label.grid(row=0, column=0, sticky="ew")
        
        progress_container = ctk.CTkFrame(footer_frame, fg_color="transparent")
        progress_container.grid(row=1, column=0, sticky="ew", pady=(5, 0))
        progress_container.grid_columnconfigure(0, weight=1)

        self.progress_bar = ctk.CTkProgressBar(progress_container, height=12)
        self.progress_bar.set(0)
        self.progress_bar.grid(row=0, column=0, sticky="ew")

        self.percentage_label = ctk.CTkLabel(progress_container, text="", font=ctk.CTkFont(size=12, weight="bold"))
        self.percentage_label.grid(row=0, column=0, sticky="ew")

    def on_closing(self):
        self.is_closing = True
        self.destroy()
    
    def sanitize_filename(self, filename):
        return "".join(c for c in filename if c not in r'<>:"/\|?*')

    def get_video_info_thread(self):
        url = self.url_entry.get().strip()
        if not url:
            self.status_label.configure(text="Error: Please enter a URL")
            return
            
        self.current_url = url
        self.get_info_button.configure(state="disabled", text="Analyzing...")
        self.status_label.configure(text="Fetching video information...")
        self.progress_bar.set(0)
        self.percentage_label.configure(text="")
        
        for widget in self.scrollable_frame.winfo_children():
            widget.destroy()
        
        self.video_title_label.configure(text="Loading video information...")
        
        thread = threading.Thread(target=self.fetch_and_display_info, args=(url,), daemon=True)
        thread.start()

    def fetch_and_display_info(self, url):
        if self.is_closing: return
        try:
            with yt_dlp.YoutubeDL(self.ydl_base_opts) as ydl:
                info_dict = ydl.extract_info(url, download=False)
            if not self.is_closing:
                self.after(0, self.update_ui_with_info, info_dict)
        except Exception as e:
            if not self.is_closing:
                self.after(0, self.update_ui_on_error, e)

    def update_ui_with_info(self, info_dict):
        if self.is_closing: return
        title = info_dict.get('title', 'No Title')
        self.video_title_label.configure(text=f"üé¨ {title}")
        
        formats = info_dict.get('formats', [])
        
        audio_streams = [f for f in formats if f.get('vcodec') == 'none' and f.get('acodec') != 'none']
        best_audio = max(audio_streams, key=lambda x: x.get('abr') or 0, default=None)
        
        video_formats = {}
        for f in sorted(formats, key=lambda x: x.get('height') or 0, reverse=True):
            height = f.get('height')
            if height and height >= 360 and height not in video_formats and f.get('vcodec') != 'none':
                video_formats[height] = f

        self.download_buttons = []
        row_index = 0
        
        if best_audio:
            self.create_format_row(f"üéµ Audio Only ({best_audio.get('ext', 'na')}, ~{best_audio.get('abr', 0)}k)", best_audio, title, row_index, None, best_audio['format_id'])
            row_index += 1

        for height, f in video_formats.items():
            is_adaptive = f.get('acodec') == 'none'
            if is_adaptive and not best_audio: continue
            self.create_format_row(f"üìπ {height}p ({f.get('ext', 'na')})", f, title, row_index, f['format_id'], best_audio['format_id'] if is_adaptive else None)
            row_index += 1

        self.status_label.configure(text="Ready to download" if row_index > 0 else "No downloadable formats found (360p+).")
        self.get_info_button.configure(state="normal", text="Analyze")

    def create_format_row(self, label_text, format_dict, title, row, video_format_id, audio_format_id):
        format_frame = ctk.CTkFrame(self.scrollable_frame, fg_color=("gray90", "gray20"))
        format_frame.grid(row=row, column=0, sticky="ew", padx=5, pady=4)
        format_frame.grid_columnconfigure(0, weight=1)
        filesize = format_dict.get('filesize') or format_dict.get('filesize_approx')
        filesize_mb = f"{round(filesize / (1024*1024), 2)} MB" if filesize else "N/A"
        ctk.CTkLabel(format_frame, text=label_text, anchor="w").grid(row=0, column=0, sticky="ew", padx=10, pady=8)
        ctk.CTkLabel(format_frame, text=f"{filesize_mb}", anchor="e", font=ctk.CTkFont(slant="italic")).grid(row=0, column=1, sticky="e", padx=10)
        download_button = ctk.CTkButton(format_frame, text="Download", width=90, height=28, command=lambda: self.start_download_thread(title, video_format_id, audio_format_id))
        download_button.grid(row=0, column=2, sticky="e", padx=(0, 10))
        
        if not hasattr(self, 'download_buttons'):
            self.download_buttons = []
        self.download_buttons.append(download_button)

    def start_download_thread(self, title, video_format_id, audio_format_id):
        self.get_info_button.configure(state="disabled")
        for btn in getattr(self, 'download_buttons', []): btn.configure(state="disabled")
        thread = threading.Thread(target=self.download_and_process, args=(title, video_format_id, audio_format_id), daemon=True)
        thread.start()

    def download_and_process(self, title, video_format_id, audio_format_id):
        if self.is_closing: return
        safe_title = self.sanitize_filename(title)
        filetypes = [("MP4 Video", "*.mp4"), ("MKV Video", "*.mkv")] if video_format_id else [("M4A Audio", "*.m4a"), ("MP3 Audio", "*.mp3")]
        initial_ext = ".mp4" if video_format_id else ".m4a"
        save_path = filedialog.asksaveasfilename(title="Save As", initialfile=f"{safe_title}{initial_ext}", defaultextension=initial_ext, filetypes=filetypes)
        
        if not save_path:
            if not self.is_closing: self.after(0, self.reset_ui_state)
            return
            
        ydl_opts = self.ydl_base_opts.copy()
        format_specifier = f"{video_format_id}+{audio_format_id}" if video_format_id and audio_format_id else video_format_id or audio_format_id
        ydl_opts.update({'format': format_specifier, 'outtmpl': save_path, 'progress_hooks': [self.progress_hook], 'noplaylist': True})
        
        save_ext = os.path.splitext(save_path)[1][1:].lower()
        if video_format_id: ydl_opts['merge_output_format'] = save_ext or 'mp4'
        elif save_ext in ['mp3', 'm4a', 'opus', 'wav']: ydl_opts['postprocessors'] = [{'key': 'FFmpegExtractAudio', 'preferredcodec': save_ext}]

        try:
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                ydl.download([self.current_url])
            if not self.is_closing:
                self.after(0, messagebox.showinfo, "Success", f"Finished downloading:\n{os.path.basename(save_path)}")
        except Exception as e:
            if not self.is_closing: self.after(0, self.update_ui_on_error, e)
        finally:
            if not self.is_closing: self.after(0, self.reset_ui_state)

    def progress_hook(self, d):
        if self.is_closing: raise yt_dlp.utils.DownloadCancelled()
        if d['status'] == 'downloading':
            total_bytes = d.get('total_bytes') or d.get('total_bytes_estimate')
            if total_bytes:
                progress = d['downloaded_bytes'] / total_bytes
                if not self.is_closing:
                    self.after(0, self.progress_bar.set, progress)
                    self.after(0, self.percentage_label.configure, {"text": f"{progress*100:.1f}%"})
                    self.after(0, self.status_label.configure, {"text": f"Downloading... {d.get('_speed_str', '')}"})
        elif d['status'] == 'finished' and not self.is_closing:
            self.after(0, self.status_label.configure, {"text": "Processing..."})

    def reset_ui_state(self):
        if self.is_closing: return
        self.get_info_button.configure(state="normal")
        for btn in getattr(self, 'download_buttons', []): btn.configure(state="normal")
        self.download_buttons = []

    def update_ui_on_error(self, error):
        if self.is_closing: return
        error_message = str(error)
        core_error = next((line.strip() for line in reversed(error_message.split('\n')) if line.strip().upper().startswith('ERROR:')), error_message)
        print(f"--- Full yt-dlp Error ---\n{error_message}\n-------------------------")
        self.video_title_label.configure(text="An error occurred")
        self.status_label.configure(text=f"Failed: {core_error}")
        self.reset_ui_state()
        self.progress_bar.set(0)
        self.percentage_label.configure(text="")
        messagebox.showerror("Download Error", f"An error occurred:\n\n{core_error}")

if __name__ == "__main__":
    app = App()
    app.mainloop()
